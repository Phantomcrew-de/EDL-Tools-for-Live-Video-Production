<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>Phantomcrew LTC</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --pc-dark: #000436;
      --pc-dark-blue: #1D3A69;
      --pc-accent-red: #FF5050;
      --pc-gold: #C99443;
      --pc-grey: #ACACAC;
      --pc-light: #ECEBED;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #1D3A69 0%, #000436 55%, #000110 100%);
      color: var(--pc-light);
      display: flex;
      min-height: 100vh;
      align-items: center;
      justify-content: center;
    }
    .card {
      width: 100%;
      max-width: 420px;
      margin: 16px;
      padding: 18px 16px 16px;
      background: rgba(0, 4, 54, 0.95);
      border-radius: 16px;
      border: 1px solid rgba(201, 148, 67, 0.5);
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
    }
    .title-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }
    h1 {
      font-size: 1.1rem;
      margin: 0;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      display: flex;
      align-items: center;
      gap: 0.45rem;
    }
    .logo-dot {
      width: 9px;
      height: 9px;
      border-radius: 999px;
      background: var(--pc-accent-red);
      box-shadow: 0 0 10px var(--pc-accent-red);
    }
    .status-pill {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      padding: 3px 9px;
      border-radius: 999px;
      font-size: 0.72rem;
      background: rgba(12, 29, 71, 0.9);
      border: 1px solid rgba(201, 148, 67, 0.5);
    }
    .status-dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: var(--pc-accent-red);
      box-shadow: 0 0 6px var(--pc-accent-red);
    }
    .status-pill.paused .status-dot {
      background: var(--pc-grey);
      box-shadow: none;
    }
    .status-text { margin: 0; }
    .tc-display {
      margin: 6px 0 10px;
      font-family: "SF Mono", "Roboto Mono", ui-monospace, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 1.3rem;
      letter-spacing: 0.22em;
      padding: 10px 12px;
      border-radius: 999px;
      background: linear-gradient(90deg, #0C1D47, #000436);
      border: 1px solid rgba(201, 148, 67, 0.7);
      text-align: center;
    }
    .row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 6px;
      margin-bottom: 8px;
      font-size: 0.78rem;
    }
    .row-label {
      color: var(--pc-grey);
      min-width: 60px;
    }
    select, input[type="number"], input[type="text"] {
      background: rgba(0, 4, 54, 0.98);
      border-radius: 999px;
      border: 1px solid rgba(201, 148, 67, 0.7);
      padding: 5px 10px;
      color: var(--pc-light);
      font-size: 0.8rem;
      outline: none;
      appearance: none;
      -moz-appearance: none;
      -webkit-appearance: none;
    }
    select { padding-right: 22px; }
    .compact-input {
      width: 60px;
      text-align: center;
    }
    .hex-input {
      width: 90px;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }
    .time-inputs {
      display: flex;
      gap: 4px;
      align-items: center;
    }
    .time-inputs span.sep {
      font-size: 0.78rem;
      color: var(--pc-grey);
    }
    .buttons-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 6px;
      gap: 6px;
    }
    button {
      border-radius: 999px;
      border: none;
      font-size: 0.8rem;
      padding: 6px 12px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      white-space: nowrap;
    }
    #startBtn {
      background: var(--pc-accent-red);
      color: #fff;
      box-shadow: 0 0 12px rgba(255, 80, 80, 0.5);
      flex: 1;
    }
    #stopBtn {
      background: rgba(12, 29, 71, 1);
      color: var(--pc-light);
      border: 1px solid rgba(172, 172, 172, 0.6);
    }
    #resyncBtn {
      background: rgba(201, 148, 67, 0.12);
      color: var(--pc-gold);
      border: 1px solid rgba(201, 148, 67, 0.7);
      font-size: 0.78rem;
      padding: 5px 10px;
    }
    button:disabled {
      opacity: 0.4;
      box-shadow: none;
      cursor: default;
    }
    .hint {
      margin-top: 6px;
      font-size: 0.7rem;
      color: var(--pc-grey);
      text-align: right;
    }
    @media (max-width: 380px) {
      .tc-display {
        font-size: 1.15rem;
        letter-spacing: 0.18em;
      }
    }
  </style>
</head>
<body>
<div class="card">
  <div class="title-row">
    <h1><span class="logo-dot"></span>Phantomcrew LTC</h1>
    <div id="statusPill" class="status-pill paused">
      <div class="status-dot"></div>
      <p id="status" class="status-text">stopp</p>
    </div>
  </div>

  <div id="tcDisplay" class="tc-display">--:--:--:--</div>

  <div class="row">
    <div class="row-label">FPS</div>
    <select id="fps">
      <option>12</option>
      <option>23.976</option>
      <option>24</option>
      <option selected>25</option>
      <option>29.97</option>
      <option>30</option>
      <option>48</option>
      <option>50</option>
      <option>59.94</option>
      <option>60</option>
    </select>
  </div>

  <div class="row">
    <div class="row-label">UTC</div>
    <input id="utcOffset" type="number" step="1" value="0" class="compact-input">
  </div>

  <div class="row">
    <div class="row-label">Offset ms</div>
    <input id="msOffset" type="number" step="10" value="0" class="compact-input">
  </div>

  <div class="row">
    <div class="row-label">User Bits</div>
    <div class="time-inputs">
      <select id="ubMode">
        <option value="off">aus</option>
        <option value="date">Datum (ST 309)</option>
        <option value="custom">Custom</option>
      </select>
      <input id="ubHex" type="text" maxlength="8" placeholder="8 HEX" class="hex-input">
    </div>
  </div>

  <div class="row">
    <div class="row-label">Start</div>
    <div class="time-inputs">
      <input id="h" type="number" min="0" max="23" value="0" class="compact-input"><span class="sep">:</span>
      <input id="m" type="number" min="0" max="59" value="0" class="compact-input"><span class="sep">:</span>
      <input id="s" type="number" min="0" max="59" value="0" class="compact-input"><span class="sep">:</span>
      <input id="f" type="number" min="0" max="59" value="0" class="compact-input">
    </div>
  </div>

  <div class="buttons-row">
    <button id="startBtn">Start</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="resyncBtn" type="button">Jetzt</button>
  </div>

  <div class="hint">
    URL: <code>?fps=25&amp;utc=1&amp;ms=-80&amp;ub=date</code>
  </div>
</div>

<script>
(function() {
  let audioCtx = null;
  let scriptNode = null;
  let running = false;

  // fpsSignal = echte LTC Frames/s (krumm möglich)
  // fpsTc     = Frames/s im angezeigten TC (ganzzahlig)
  let fpsSignal = 25;
  let fpsTc = 25;

  let hours = 0, minutes = 0, seconds = 0, frames = 0;
  let utcOffset = 0;   // Stunden
  let msOffset = 0;    // beliebig
  let userBitsMode = "off"; // "off" | "date" | "custom"
  let userBitsHex = "";

  let sampleRate = 48000;
  let bitRate = fpsSignal * 80;
  let bitDuration = 1.0 / bitRate;
  let timeInBit = 0.0;
  let bitIndex = 0;
  let phase = 1.0;
  let midTransitionDone = false;
  let currentFrameBits = new Array(80).fill(0);

  const statusEl = document.getElementById("status");
  const statusPill = document.getElementById("statusPill");
  const fpsSelect = document.getElementById("fps");
  const utcOffsetInput = document.getElementById("utcOffset");
  const msOffsetInput = document.getElementById("msOffset");
  const ubModeSelect = document.getElementById("ubMode");
  const ubHexInput = document.getElementById("ubHex");
  const startBtn = document.getElementById("startBtn");
  const stopBtn = document.getElementById("stopBtn");
  const resyncBtn = document.getElementById("resyncBtn");
  const tcDisplay = document.getElementById("tcDisplay");

  function logStatus(text, isRunning) {
    statusEl.textContent = text;
    if (isRunning) statusPill.classList.remove("paused");
    else statusPill.classList.add("paused");
  }

  function updateTimeInputs() {
    document.getElementById("h").value = hours;
    document.getElementById("m").value = minutes;
    document.getElementById("s").value = seconds;
    document.getElementById("f").value = frames;
  }

  function updateTcDisplay() {
    const pad2 = x => x.toString().padStart(2, "0");
    tcDisplay.textContent = `${pad2(hours)}:${pad2(minutes)}:${pad2(seconds)}:${pad2(frames)}`;
  }

  function setBcd(bits, value, unitIndices, tensIndices) {
    let units = value % 10;
    let tens = Math.floor(value / 10);
    for (let i = 0; i < unitIndices.length; i++) {
      bits[unitIndices[i]] = (units >> i) & 1;
    }
    for (let i = 0; i < tensIndices.length; i++) {
      bits[tensIndices[i]] = (tens >> i) & 1;
    }
  }

  function setUserNibble(bits, nibbleVal, bitIdxArray) {
    nibbleVal = nibbleVal & 0xF;
    for (let i = 0; i < 4; i++) {
      bits[bitIdxArray[i]] = (nibbleVal >> i) & 1;
    }
  }

  function setBit(bits, idx, val) {
    bits[idx] = val ? 1 : 0;
  }

  function setBGFFlags(bits, hasDateTimezone) {
    const is25 = (Math.round(fpsTc) === 25);
    const bgf0Index = is25 ? 27 : 43;
    const bgf1Index = 58;
    const bgf2Index = is25 ? 43 : 59;

    // Clock time immer an, Date/Timezone nur bei Mode "date"
    const BGF0 = 0;
    const BGF1 = 1;                  // Clock time / Wall clock
    const BGF2 = hasDateTimezone ? 1 : 0;

    setBit(bits, bgf0Index, BGF0);
    setBit(bits, bgf1Index, BGF1);
    setBit(bits, bgf2Index, BGF2);
  }

  function applyUserBits(bits, dateInfo) {
    // dateInfo: {day, month, year} mit year = 0..99
    if (userBitsMode === "off") {
      setBGFFlags(bits, false);
      return;
    }

    if (userBitsMode === "custom") {
      setBGFFlags(bits, false);
      let hex = (userBitsHex || "").toUpperCase().replace(/[^0-9A-F]/g, "");
      while (hex.length < 8) hex += "0";
      if (hex.length > 8) hex = hex.slice(0, 8);
      for (let i = 0; i < 8; i++) {
        const val = parseInt(hex[i], 16);
        const nib = isNaN(val) ? 0 : val;
        switch (i) {
          case 0: setUserNibble(bits, nib, [4,5,6,7]); break;
          case 1: setUserNibble(bits, nib, [12,13,14,15]); break;
          case 2: setUserNibble(bits, nib, [20,21,22,23]); break;
          case 3: setUserNibble(bits, nib, [28,29,30,31]); break;
          case 4: setUserNibble(bits, nib, [36,37,38,39]); break;
          case 5: setUserNibble(bits, nib, [44,45,46,47]); break;
          case 6: setUserNibble(bits, nib, [52,53,54,55]); break;
          case 7: setUserNibble(bits, nib, [60,61,62,63]); break;
        }
      }
      return;
    }

    // Mode "date" -> SMPTE ST 309 YYMMDD + Timezone-Code
    setBGFFlags(bits, true);

    const d = dateInfo.day;
    const m = dateInfo.month;
    const y = dateInfo.year % 100;

    const dUnits = d % 10;
    const dTens  = Math.floor(d / 10);
    const mUnits = m % 10;
    const mTens  = Math.floor(m / 10);
    const yUnits = y % 10;
    const yTens  = Math.floor(y / 10);

    // Binary Groups 1..6 -> BCD-Digits (YYMMDD nach ST 309)
    // BG1: day units
    setUserNibble(bits, dUnits, [4,5,6,7]);
    // BG2: day tens
    setUserNibble(bits, dTens, [12,13,14,15]);
    // BG3: month units
    setUserNibble(bits, mUnits, [20,21,22,23]);
    // BG4: month tens
    setUserNibble(bits, mTens, [28,29,30,31]);
    // BG5: year units
    setUserNibble(bits, yUnits, [36,37,38,39]);
    // BG6: year tens
    setUserNibble(bits, yTens, [44,45,46,47]);

    // Timezone-Code (6 Bit) + DST + MJD-Flag in BG7/BG8
    // Hier: Code 0 (= UTC) als sicherer Standard,
    // DST=0, MJD=0 (YYMMDD-Format)
    const tzCode = 0;  // 0..63
    const dstFlag = 0;
    const mjdFlag = 0;

    const tzLow  = tzCode & 0x0F;        // BG7
    const tzHigh = (tzCode >> 4) & 0x03; // in BG8 Bits 0..1

    const bg7Nib = tzLow;
    const bg8Nib = tzHigh | (dstFlag << 2) | (mjdFlag << 3);

    // BG7: bits 52..55, BG8: bits 60..63
    setUserNibble(bits, bg7Nib, [52,53,54,55]);
    setUserNibble(bits, bg8Nib, [60,61,62,63]);
  }

  function buildFrameBits(h, m, s, f, fpsTcVal, dateInfo) {
    let bits = new Array(80).fill(0);

    // Timecode BCD
    setBcd(bits, f, [0,1,2,3], [8,9]);
    setBcd(bits, s, [16,17,18,19], [24,25,26]);
    setBcd(bits, m, [32,33,34,35], [40,41,42]);
    setBcd(bits, h, [48,49,50,51], [56,57]);

    // Flags: non-drop, kein spezielles Color-Frame-Flag
    bits[10] = 0; // DF
    bits[11] = 0; // CF

    // User Bits + BGF nach Mode
    applyUserBits(bits, dateInfo);

    // Sync-Word (64–79)
    const syncPattern = [0,0,1,1, 1,1,1,1, 1,1,1,1, 1,1,0,1];
    for (let i = 0; i < 16; i++) bits[64 + i] = syncPattern[i];

    // Parity / Phase Correction (libltc: 25fps vs. 24/30)
    const parityIndex = (Math.round(fpsTcVal) === 25) ? 59 : 27;
    bits[parityIndex] = 0;
    let zeroCount = 0;
    for (let i = 0; i < 80; i++) if (bits[i] === 0) zeroCount++;
    if (zeroCount % 2 === 1) bits[parityIndex] = 1;

    return bits;
  }

  function incrementTimecode() {
    frames++;
    if (frames >= fpsTc) {
      frames = 0;
      seconds++;
      if (seconds >= 60) {
        seconds = 0;
        minutes++;
        if (minutes >= 60) {
          minutes = 0;
          hours = (hours + 1) % 24;
        }
      }
    }
  }

  function resetBitstream(dateInfo) {
    bitRate = fpsSignal * 80;
    bitDuration = 1.0 / bitRate;
    timeInBit = 0.0;
    bitIndex = 0;
    phase = 1.0;
    midTransitionDone = false;
    currentFrameBits = buildFrameBits(hours, minutes, seconds, frames, fpsTc, dateInfo);
    updateTcDisplay();
  }

  function generateSample(dateInfo) {
    if (!running) return 0.0;
    const dt = 1.0 / sampleRate;
    timeInBit += dt;

    let currentBit = currentFrameBits[bitIndex];

    if (currentBit === 1 && !midTransitionDone && timeInBit >= bitDuration / 2) {
      phase = -phase;
      midTransitionDone = true;
    }

    if (timeInBit >= bitDuration) {
      timeInBit -= bitDuration;
      phase = -phase;
      bitIndex++;
      midTransitionDone = false;

      if (bitIndex >= 80) {
        bitIndex = 0;
        incrementTimecode();
        const dateInfoNow = getCurrentDateInfo();
        currentFrameBits = buildFrameBits(hours, minutes, seconds, frames, fpsTc, dateInfoNow);
        updateTcDisplay();
      }
    }
    return phase * 0.6;
  }

  function getCurrentDateInfo() {
    const now = new Date();
    const offsetMs = (utcOffset * 3600 * 1000) + msOffset;
    const local = new Date(now.getTime() + offsetMs);

    return {
      year: local.getUTCFullYear() % 100,
      month: local.getUTCMonth() + 1,
      day: local.getUTCDate()
    };
  }

  function syncToClock() {
    const now = new Date();
    const offsetMs = (utcOffset * 3600 * 1000) + msOffset;
    const local = new Date(now.getTime() + offsetMs);

    hours = local.getUTCHours();
    minutes = local.getUTCMinutes();
    seconds = local.getUTCSeconds();
    const ms = local.getUTCMilliseconds();

    let f = Math.floor((ms / 1000) * fpsSignal);
    if (f >= fpsTc) f = fpsTc - 1;
    frames = f;

    updateTimeInputs();
    updateTcDisplay();
    const dateInfo = getCurrentDateInfo();
    resetBitstream(dateInfo);
  }

  function applyFpsFromSelect() {
    const valStr = fpsSelect.value;
    const val = parseFloat(valStr);

    if (Math.abs(val - 23.976) < 0.001) {
      fpsSignal = 24000 / 1001;
      fpsTc = 24;
    } else if (Math.abs(val - 29.97) < 0.001) {
      fpsSignal = 30000 / 1001;
      fpsTc = 30;
    } else if (Math.abs(val - 59.94) < 0.001) {
      fpsSignal = 60000 / 1001;
      fpsTc = 60;
    } else {
      fpsSignal = val;
      fpsTc = Math.round(val);
    }
  }

  function updateUrlFromState() {
    const params = new URLSearchParams(window.location.search);
    params.set("fps", fpsSelect.value);
    params.set("utc", utcOffset.toString());
    params.set("ms", msOffset.toString());
    params.set("ub", userBitsMode);
    if (userBitsMode === "custom") {
      params.set("ubhex", userBitsHex);
    } else {
      params.delete("ubhex");
    }
    const newUrl = window.location.pathname + "?" + params.toString();
    window.history.replaceState({}, "", newUrl);
  }

  function updateUbInputDisabled() {
    const disabled = userBitsMode !== "custom";
    ubHexInput.disabled = disabled;
    ubHexInput.style.opacity = disabled ? 0.4 : 1;
  }

  function initializeFromUrl() {
    const params = new URLSearchParams(window.location.search);

    const urlFps = params.get("fps");
    if (urlFps) {
      const options = Array.from(fpsSelect.options).map(o => o.value);
      if (options.includes(urlFps)) fpsSelect.value = urlFps;
    }
    applyFpsFromSelect();

    const urlUtc = params.get("utc");
    if (urlUtc !== null) {
      const val = parseFloat(urlUtc);
      if (!isNaN(val)) utcOffset = val;
    }
    utcOffsetInput.value = utcOffset.toString();

    const urlMs = params.get("ms");
    if (urlMs !== null) {
      const valMs = parseFloat(urlMs);
      if (!isNaN(valMs)) msOffset = valMs;
    }
    msOffsetInput.value = msOffset.toString();

    const urlUb = params.get("ub");
    if (urlUb === "date" || urlUb === "custom" || urlUb === "off") {
      userBitsMode = urlUb;
    } else {
      userBitsMode = "off";
    }
    ubModeSelect.value = userBitsMode;

    const urlUbHex = params.get("ubhex");
    if (urlUbHex) {
      userBitsHex = urlUbHex.toUpperCase().replace(/[^0-9A-F]/g, "").slice(0,8);
    }
    ubHexInput.value = userBitsHex;

    updateUbInputDisabled();
    syncToClock();
    updateUrlFromState();
  }

  function startLTCInternal() {
    applyFpsFromSelect();
    utcOffset = parseFloat(utcOffsetInput.value) || 0;
    msOffset = parseFloat(msOffsetInput.value) || 0;
    syncToClock();
    running = true;
    startBtn.disabled = true;
    stopBtn.disabled = false;
    logStatus("läuft", true);
    updateUrlFromState();
  }

  function startLTCWithUserGesture() {
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      sampleRate = audioCtx.sampleRate;
      scriptNode = audioCtx.createScriptProcessor(1024, 0, 1);
      scriptNode.onaudioprocess = function(e) {
        const out = e.outputBuffer.getChannelData(0);
        const dateInfo = getCurrentDateInfo();
        for (let i = 0; i < out.length; i++) {
          out[i] = generateSample(dateInfo);
        }
      };
      scriptNode.connect(audioCtx.destination);
    } else {
      sampleRate = audioCtx.sampleRate;
    }

    audioCtx.resume().then(() => {
      startLTCInternal();
    }).catch(() => {
      logStatus("Tap zum Starten", false);
    });
  }

  function stopLTC() {
    running = false;
    startBtn.disabled = false;
    stopBtn.disabled = true;
    logStatus("stopp", false);
  }

  // UI Events
  startBtn.addEventListener("click", startLTCWithUserGesture);
  stopBtn.addEventListener("click", stopLTC);

  resyncBtn.addEventListener("click", function() {
    syncToClock();
    updateUrlFromState();
  });

  fpsSelect.addEventListener("change", function() {
    applyFpsFromSelect();
    updateUrlFromState();
    syncToClock();
    if (running) resetBitstream(getCurrentDateInfo());
  });

  utcOffsetInput.addEventListener("change", function() {
    utcOffset = parseFloat(this.value) || 0;
    updateUrlFromState();
    syncToClock();
    if (running) resetBitstream(getCurrentDateInfo());
  });

  msOffsetInput.addEventListener("change", function() {
    msOffset = parseFloat(this.value) || 0;
    updateUrlFromState();
    syncToClock();
    if (running) resetBitstream(getCurrentDateInfo());
  });

  ubModeSelect.addEventListener("change", function() {
    userBitsMode = this.value;
    updateUbInputDisabled();
    updateUrlFromState();
    if (running) resetBitstream(getCurrentDateInfo());
  });

  ubHexInput.addEventListener("input", function() {
    userBitsHex = this.value.toUpperCase().replace(/[^0-9A-F]/g, "").slice(0,8);
    this.value = userBitsHex;
    updateUrlFromState();
    if (running) resetBitstream(getCurrentDateInfo());
  });

  window.addEventListener("load", function() {
    initializeFromUrl();
    logStatus("stopp", false);
  });
})();
</script>
</body>
</html>
