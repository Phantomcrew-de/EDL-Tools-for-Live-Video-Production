<!DOCTYPE html>

<html lang="de">
<head>
<meta charset="utf-8"/>

<!-- PWA Meta Tags -->
<meta name="theme-color" content="#000436" />
<meta name="description" content="browser-based web applications to support timecode-based editing and video annotation workflows, particularly for live productions and DaVinci Resolve postproduction." />
<link rel="manifest" href="/manifest.json" />
<link rel="apple-touch-icon" href="/icons/icon-192x192.png" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
<meta name="apple-mobile-web-app-title" content="EDL Tools Suite" />

<title>EDL-Tools Roundtrip Suite</title>

<style>
    html, body { height: 100%; margin: 0; padding: 0; }
    body { background: #181818; color: #eee; margin: 0; font-family: sans-serif; height: 100vh; }
    .tab-container { display: flex; background: #000436; }
    .tab {
      cursor: pointer;
      padding: 12px 22px;
      color: #aaa;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 17px;
      position: relative;
      transition: background 0.3s;
      border-bottom: 2.5px solid transparent;
    }
    .tab.active {
      background: #444;
      color: #fff;
      border-bottom: 2.5px solid #FF5050;
    }
    .tab-content {
      display: none;
      position: absolute;
      top: 48px;
      left: 0;
      width: 100%;
      height: calc(100vh - 48px);
      background: transparent;
      z-index: 0;
      overflow: hidden;
    }
    .tab-content::before {
      content: "";
      position: absolute;
      inset: 0;
      background: #0b0b3b;
      z-index: 0;
      pointer-events: none;
    }
    .tab-content .swipe-inner {
      width: 100%;
      height: 100%;
      transition: none;
      will-change: transform, opacity;
      background: transparent;
      display: flex;
      flex-direction: column;
      justify-content: stretch;
      align-items: stretch;
      opacity: 1;
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 1;
    }
    .tab-content.active {
      display: block;
      z-index: 1;
    }
    iframe {
      width: 100%;
      height: 100%;
      border: none;
      background: #000436;
      display: block;
      flex: 1 1 0%;
    }
    .github-link {
      margin-left: auto;
      display: flex;
      align-items: center;
      padding: 0 16px;
      text-decoration: none;
      background: none;
      border: none;
      cursor: pointer;
      height: 48px;
    }
    .github-link svg {
      width: 26px;
      height: 26px;
      fill: #aaa;
      transition: fill 0.2s;
    }
    .github-link:hover svg {
      fill: #30c7ff;
    }
    .atem-lang-switch {
      display: flex;
      gap: 10px;
      justify-content: flex-end;
      align-items: center;
      margin: 0;
      padding: 7px 14px 6px 0;
      background: linear-gradient(90deg, #393c40 75%, #43484e 100%);
      border-radius: 0 0 12px 12px;
      box-shadow: 0 2px 8px 0 #0004;
      position: relative;
      z-index: 5;
      min-height: 38px;
    }
    .atem-lang-btn {
      font-size: 23px;
      background: none;
      border: none;
      cursor: pointer;
      filter: grayscale(0.4) brightness(1.6) drop-shadow(0 0 2px #fff8);
      transition: filter 0.2s, transform 0.12s, background 0.18s;
      outline: none;
      padding: 0 6px;
      border-radius: 7px;
      position: relative;
      top: 1px;
      line-height: 1.15;
      box-shadow: 0 1px 2px #0002;
    }
    .atem-lang-btn.active {
      filter: grayscale(0) brightness(2.1) drop-shadow(0 2px 6px #30c7ff88);
      background: #30c7ff33;
      transform: scale(1.17);
    }
    .atem-lang-btn:hover, .atem-lang-btn:focus {
      filter: grayscale(0.1) brightness(2.3) drop-shadow(0 0 3px #fff) drop-shadow(0 1px 8px #30c7ffcc);
      background: #30c7ff66;
    }
    .atem-iframe { display: none; }
    .atem-iframe.active { display: block; }
    @keyframes swipe-in-left { from { transform: translateX(-60px); opacity:0; } to { transform: translateX(0); opacity:1; } }
    @keyframes swipe-in-right { from { transform: translateX(60px); opacity:0; } to { transform: translateX(0); opacity:1; } }
	.tab-container {
  display: flex;
  align-items: center;
  background: #040520;
}

.logo {
  height: 34px;         /* oder je nach Bedarf */
  margin-right: 22px;   /* Abstand zu den Tabs */
  margin-left: 14px;    /* evtl. etwas Abstand links */
  margin-bottom: 1px;    /* evtl. etwas Abstand unten */
  margin-top: 3px;
  user-select: none;
  pointer-events: none;
}

#tab-highlight-bar {
  position: absolute;
  height: 42px;
  background: linear-gradient(90deg, #202038, #2b2b4d);
  border-radius: 12px;
  transition: left 0.38s cubic-bezier(0.77,0,0.18,1), width 0.38s cubic-bezier(0.77,0,0.18,1);
  z-index: 0;
  top: 3px;
  pointer-events: none;
}

</style>
</head>
<body>
<div class="tab-container">
<div id="tab-highlight-bar"></div>
<a class="logo-link" href="https://phantomcrew.de/" target="_blank" title="Phantomcrew-Website">
<img alt="Phantomcrew Logo" class="logo" src="graphics/Phantomcrew_Logo_nebeneinander_02_lq.png"/>
</a>
<div class="tab active" data-hash="#atem" data-target="atem">üéõÔ∏è</div>
<div class="tab" data-hash="#resolve" data-target="resolve">üé¨</div>
<div class="tab" data-hash="#offset" data-target="offset">üìù</div>
<div class="tab" data-hash="#color" data-target="color">üé®</div>
<div class="tab" data-hash="#help" data-target="help">üìö</div>
<a class="github-link" href="https://github.com/phantomcrew-de/EDL-Tools-for-Live-Video-Production" id="github-link" rel="noopener" target="_blank" title="GitHub Repository">
<svg viewbox="0 0 16 16">
<path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38
        0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52
        0-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95
        0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2
        .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15
        0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013
        8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path>
</svg>
</a>
</div>
<div class="tab-content active" id="tab-atem" style="background:transparent;">
<div class="swipe-inner">
<div class="atem-lang-switch">
<button class="atem-lang-btn" data-lang="DE" title="Deutsch">üá©üá™ DE</button>
<button class="atem-lang-btn" data-lang="EN" title="English">üá¨üáß EN</button>
</div>
<iframe class="atem-iframe" id="iframe-atem-de" src="EDL_for_ATEM_live_production_1_2_DE.html"></iframe>
<iframe class="atem-iframe" id="iframe-atem-en" src="EDL_for_ATEM_live_production_1_2_EN.html"></iframe>
</div>
</div>
<div class="tab-content" id="tab-resolve" style="background:transparent;">
<div class="swipe-inner"><iframe class="atem-iframe active" id="iframe-resolve" src="EDL_video_player_for_resolve_2_0_EN_DE.html"></iframe></div>
</div>
<div class="tab-content" id="tab-offset" style="background:transparent;">
<div class="swipe-inner">
<iframe id="iframe-offset" src="EDL_Offset_Editor_1_1_EN.html"></iframe>
</div>
</div>
<div class="tab-content" id="tab-color" style="background:transparent;">
<div class="swipe-inner">
<iframe id="iframe-color" src="EDL_Color_Replace_1_2_EN.html"></iframe>
</div>
</div>
<div class="tab-content" id="tab-help" style="background:transparent;">
<div class="swipe-inner">
<iframe id="iframe-help" src="https://phantomcrew-de.github.io/EDL-Tools-for-Live-Video-Production/help.html"></iframe>
</div>
</div>
<script>
// *** DIESE ZEILE ERZ√ÑWGT DEN STANDARD-HASH BEIM ERSTEN AUFRUF ***
if(!window.location.hash || window.location.hash === "#") {
  window.location.hash = "#atem?lang=en";
}

// Rest vom Script:
window.globalEDLText = "";
let tabOrder = ["atem", "resolve", "offset", "color", "help"];
let currentTab = "atem";
let switchingTab = false;

// ---- Hilfsfunktionen f√ºr Hash/Query-Parsing ----
function getHashTabAndQuery() {
  const hash = window.location.hash.replace(/^#/, '');
  const [tab, query] = hash.split('?');
  const params = {};
  if (query) {
    query.split('&').forEach(pair => {
      let [k, v] = pair.split('=');
      if (k && v) params[k] = v;
    });
  }
  return { tab: tab || 'atem', params };
}

function setHash(tab, params = {}) {
  let hash = '#' + tab;
  const query = Object.entries(params).map(([k, v]) => `${k}=${v}`).join('&');
  if (query) hash += '?' + query;
  if (window.location.hash !== hash) window.location.hash = hash;
}

// ---- ATEM Language Switch f√ºr parallele iframes + persistente Sprache ----
let currentAtemLang = localStorage.getItem("lastAtemLang") || "EN";
function getAtemLangFromParams(params) {
  if (params.lang && params.lang.toLowerCase() === "de") return "DE";
  if (params.lang && params.lang.toLowerCase() === "en") return "EN";
  return null;
}
function setAtemLangQuery(lang) {
  const { tab, params } = getHashTabAndQuery();
  if (tab !== "atem") return;
  const newParams = { ...params, lang: lang.toLowerCase() };
  setHash(tab, newParams);
}
function setAtemLang(lang, updateUrl=true) {
  lang = (lang === "DE") ? "DE" : "EN";
  currentAtemLang = lang;
  localStorage.setItem("lastAtemLang", lang);
  document.getElementById('iframe-atem-de').classList.toggle('active', lang === "DE");
  document.getElementById('iframe-atem-en').classList.toggle('active', lang === "EN");
  
document.querySelectorAll('#tab-color .atem-lang-btn').forEach(btn => {
  btn.addEventListener('click', (e) => {
    setColorLang(btn.dataset.lang, true);
  });
});

document.querySelectorAll('.atem-lang-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.lang === lang);
  });
  if (updateUrl) setAtemLangQuery(lang);
}


let currentColorLang = localStorage.getItem("lastColorLang") || "EN";
function setColorLangQuery(lang) {
  const { tab, params } = getHashTabAndQuery();
  if (tab !== "color") return;
  const newParams = { ...params, lang: lang.toLowerCase() };
  setHash(tab, newParams);
}
function setColorLang(lang, updateUrl=true) {
  lang = (lang === "EN") ? "EN" : "DE";
  currentColorLang = lang;
  localStorage.setItem("lastColorLang", lang);
  document.getElementById('iframe-color').src = (lang === "DE")
    ? "EDL_Color_Replace_1_2_DE.html"
    : "EDL_Color_Replace_1_2_EN.html";
  document.querySelectorAll('#tab-color .atem-lang-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.lang === lang);
  });
  if (updateUrl) setColorLangQuery(lang);
}

// ---- RESOLVE Language Switch ----
let currentResolveLang = localStorage.getItem("lastResolveLang") || "DE";
function getResolveLangFromParams(params) {
  if (params.lang && params.lang.toLowerCase() === "de") return "DE";
  if (params.lang && params.lang.toLowerCase() === "en") return "EN";
  return null;
}
function setResolveLangQuery(lang) {
  const { tab, params } = getHashTabAndQuery();
  if (tab !== "resolve") return;
  const newParams = { ...params, lang: lang.toLowerCase() };
  setHash(tab, newParams);
}
function setResolveLang(lang, updateUrl=true) {
  lang = (lang === "EN") ? "EN" : "DE";
  currentResolveLang = lang;
  localStorage.setItem("lastResolveLang", lang);
  document.getElementById('iframe-resolve-de').classList.toggle('active', lang === "DE");
  document.getElementById('iframe-resolve-en').classList.toggle('active', lang === "EN");
  document.querySelectorAll('#tab-resolve .atem-lang-btn').forEach(btn => {
    btn.classList.toggle('active', btn.dataset.lang === lang);
  });
  if (updateUrl) setResolveLangQuery(lang);
}
document.querySelectorAll('#tab-resolve .atem-lang-btn').forEach(btn => {
  btn.addEventListener('click', (e) => {
    setResolveLang(btn.dataset.lang, true);
  });
});


document.querySelectorAll('#tab-color .atem-lang-btn').forEach(btn => {
  btn.addEventListener('click', (e) => {
    setColorLang(btn.dataset.lang, true);
  });
});

document.querySelectorAll('.atem-lang-btn').forEach(btn => {
  btn.addEventListener('click', (e) => {
    setAtemLang(btn.dataset.lang, true);
  });
});

function doSwipe(outTab, inTab, dir, cb) {
  if (!outTab || !inTab) { if(cb)cb(); return; }
  const outContent = outTab.querySelector('.swipe-inner');
  const inContent = inTab.querySelector('.swipe-inner');
  if (!outContent || !inContent) { if(cb)cb(); return; }
  outContent.style.animation = '';
  inContent.style.animation = '';
  inContent.style.transform = '';
  outContent.style.transform = '';
  inTab.style.zIndex = 2;
  outTab.style.zIndex = 1;
  inContent.style.zIndex = 2;
  outContent.style.zIndex = 1;
  outTab.classList.remove('active');
  outTab.style.zIndex = 0;
  outContent.style.animation = '';
  inTab.classList.add('active');
  inContent.style.animation = `swipe-in-${dir} 0.38s cubic-bezier(0.77,0,0.18,1) forwards`;
  inTab.style.zIndex = 1;
  setTimeout(() => {
    inContent.style.animation = '';
    if (cb) cb();
  }, 380);
}

document.querySelectorAll('.tab').forEach(tab => {
  tab.addEventListener('click', () => {
    const nextTab = tab.dataset.target;
    if (switchingTab || nextTab === currentTab) return;
    switchingTab = true;
    let params = {};
const { params: hashParams } = getHashTabAndQuery();

if (typeof nextTab === "string" && nextTab.toLowerCase() === "atem") {
  if (hashParams.lang) params.lang = hashParams.lang;
}

if (typeof nextTab === "string" && nextTab.toLowerCase() === "resolve") {
  const ALLOWED = new Set(["v","list","t","time","start","lang"]);
  Object.keys(hashParams || {}).forEach(k => {
    if (ALLOWED.has(k)) params[k] = hashParams[k];
  });
}

// Falls wir in den Resolve-Tab wechseln und noch KEINE Params im Hash sind,
// nimm die zuletzt bekannten Resolve-Params (nur Session, kein Cookie/kein localStorage).
if (typeof nextTab === "string" && nextTab.toLowerCase() === "resolve") {
  const haveParams = Object.keys(params).length > 0;
  if (!haveParams) {
    try {
      const cached = JSON.parse(sessionStorage.getItem('edl_resolve_params') || "{}");
      const ALLOWED = new Set(["v","list","t","time","start","lang"]);
      Object.keys(cached || {}).forEach(k => {
        if (ALLOWED.has(k) && !params[k]) params[k] = cached[k];
      });
    } catch (e) {}
  }
}
setHash(nextTab, params);
    exportEDLFromTab(currentTab);
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    tab.classList.add('active');
    const fromIdx = tabOrder.indexOf(currentTab);
    const toIdx = tabOrder.indexOf(nextTab);
    let dir = (toIdx > fromIdx) ? 'right' : 'left';
    const currentContent = document.getElementById('tab-' + currentTab);
    const nextContent = document.getElementById('tab-' + nextTab);
    doSwipe(currentContent, nextContent, dir, () => {
      setTimeout(() => importEDLToTab(nextTab), 180);
      currentTab = nextTab;
      switchingTab = false;
      if (nextTab === "atem") {
        const { params: hashParams } = getHashTabAndQuery();
        // 1. Sprachparameter aus URL bevorzugen
        let newLang = getAtemLangFromParams(hashParams);
        // 2. Falls keiner gesetzt, zuletzt genutzte Sprache (persistiert) verwenden
        if (!newLang) newLang = localStorage.getItem("lastAtemLang") || "EN";
        setAtemLang(newLang, false);
      }

      if (nextTab === "resolve") {
        const { params: hashParams } = getHashTabAndQuery();
    if (nextTab === "color") {
      const { params: hashParams } = getHashTabAndQuery();
      let newLang = getResolveLangFromParams(hashParams);
      if (!newLang) newLang = localStorage.getItem("lastColorLang") || "EN";
      setColorLang(newLang, false);
    }

        let newLang = getResolveLangFromParams(hashParams);
        if (!newLang) newLang = localStorage.getItem("lastResolveLang") || "DE";
        setResolveLang(newLang, false);
      }
    });
  });
});

function activateTabFromHash() {
  const { tab, params } = getHashTabAndQuery();
  const tabBtn = Array.from(document.querySelectorAll('.tab')).find(t => t.dataset.target === tab);
  if (tabBtn) tabBtn.click();
  if (tab === "atem") {
    // 1. Sprachparameter aus URL bevorzugen
    let newLang = getAtemLangFromParams(params);
    // 2. Falls keiner gesetzt, zuletzt genutzte Sprache (persistiert) verwenden
    if (!newLang) newLang = localStorage.getItem("lastAtemLang") || "EN";
    setTimeout(() => setAtemLang(newLang, false), 120);
  }

  if (tab === "resolve") {
    let newLang = getResolveLangFromParams(params);
  if (tab === "color") {
    let newLang = getResolveLangFromParams(params);
    if (!newLang) newLang = localStorage.getItem("lastColorLang") || "EN";
    setTimeout(() => setColorLang(newLang, false), 120);
  }

    if (!newLang) newLang = localStorage.getItem("lastResolveLang") || "DE";
    setTimeout(() => setResolveLang(newLang, false), 120);
  }
}

window.addEventListener('DOMContentLoaded', () => {
  activateTabFromHash();
  document.querySelectorAll('.tab-content').forEach((div, idx) => {
    if (!div.classList.contains('active')) div.style.zIndex = 0;
    else div.style.zIndex = 1;
  });
});

window.addEventListener('hashchange', () => {
  activateTabFromHash();
});

function exportEDLFromTab(tabId) {
  const iframe = document.getElementById('iframe-' + tabId);
  if(iframe && iframe.contentWindow)
    iframe.contentWindow.postMessage({type: 'EXPORT_EDL'}, '*');
}
function importEDLToTab(tabId) {
  if (window.globalEDLText && window.globalEDLText.length > 0) {
    const iframe = document.getElementById('iframe-' + tabId);
    if(iframe && iframe.contentWindow)
      iframe.contentWindow.postMessage({type: 'IMPORT_EDL', edl: window.globalEDLText}, '*');
  }
}
window.addEventListener('message', (event) => {
  if (event.data.type === 'EXPORT_RESULT' && typeof event.data.edl === 'string') {
    window.globalEDLText = event.data.edl;
  }
});


function updateHighlightBar() {
  const activeTab = document.querySelector('.tab.active');
  const bar = document.getElementById('tab-highlight-bar');
  if (!activeTab || !bar) return;
  const rect = activeTab.getBoundingClientRect();
  const containerRect = document.querySelector('.tab-container').getBoundingClientRect();
  bar.style.left = (rect.left - containerRect.left) + "px";
  bar.style.width = rect.width + "px";
}
window.addEventListener('DOMContentLoaded', () => {
  updateHighlightBar();
  setTimeout(updateHighlightBar, 150);
});
window.addEventListener('resize', () => setTimeout(updateHighlightBar, 100));
document.querySelectorAll('.tab').forEach(tab => {
  tab.addEventListener('click', () => {
    setTimeout(updateHighlightBar, 80);
  });
});

</script>
<script>
document.addEventListener("DOMContentLoaded", () => {
  const tabs = Array.from(document.querySelectorAll(".tab"));
  const tabLabelMap = {
    "atem": "üéõÔ∏è EDL Live",
    "resolve": "üé¨ EDL Player",
    "offset": "üìù EDL Offset",
    "color": "üé® EDL Color",
    "help": "üìö Read Me"
  }; Array.from(document.querySelectorAll(".tab"));
  const container = document.querySelector(".tab-container");

  // Fr√ºhzeitig iOS Safari ignorieren (hat eigenes Styling)
  const ua = navigator.userAgent;
  const isIOS = /iP(hone|ad|od)/.test(ua) || (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1);
  const isSafari = /^((?!chrome|android).)*safari/i.test(ua);
let applyOrientationEmojiMode = null;

const isIPadOS = (/iPad/.test(ua) || (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1));
// Orientation-specific handling for iPad Safari
if (isIPadOS && isSafari) {
  window.skipAutoSwitch = true;      // disable width-based auto switch for iPad
  applyOrientationEmojiMode = function() {
    const isLandscape = window.matchMedia("(orientation: landscape)").matches;
    // Landscape => show text labels (emojiMode false), Portrait => emojis (true)
    if (typeof setEmojiMode === 'function') {
      setEmojiMode(!isLandscape);
    }
  }
// handle orientation changes
  window.addEventListener("orientationchange", () => {
    setTimeout(applyOrientationEmojiMode, 100);
  });
}
  if (/iPhone/.test(ua) && isSafari) return;

  // Originaltexte + Emojis merken
  
  tabs.forEach(tab => {
    const id = tab.dataset.target;
    if (!tab.dataset.full && tabLabelMap[id]) {
      const full = tabLabelMap[id];
      const emoji = full.split(" ")[0];
      tab.dataset.full = full;
      tab.dataset.emoji = emoji;
    }
  });

// Nach dem Setzen von dataset.full & .emoji -> iPad‚ÄëOrientation‚ÄëModus anwenden
if (isIPadOS && isSafari && typeof applyOrientationEmojiMode === "function") {
  applyOrientationEmojiMode();
}

    

  // Breite aller Tabs im Volltext-Modus berechnen
  function calcFullWidth() {
    const probe = document.createElement("span");
    probe.style.position = "absolute";
    probe.style.whiteSpace = "nowrap";
    probe.style.visibility = "hidden";
    probe.style.font = getComputedStyle(tabs[0]).font;
    document.body.appendChild(probe);

    let w = 0;
    tabs.forEach(tab => { probe.textContent = tab.dataset.full; w += probe.offsetWidth; });

    const gap = parseInt(getComputedStyle(tabs[0]).gap || "10", 10);
    w += gap * (tabs.length - 1);
    document.body.removeChild(probe);
    return w;
  }

  const fullWidth = calcFullWidth();
  const THRESH_NARROW = fullWidth + 429;
  const THRESH_WIDE   = fullWidth + 429;

  // Emoji-Modus Zustand merken und laden
  let emojiMode = true;
  localStorage.setItem("emojiMode", "1");

  // Highlight-Bar aktualisieren
  function updateHighlightBar() {
    const activeTab = document.querySelector('.tab.active');
    const bar = document.getElementById('tab-highlight-bar');
    const container = document.querySelector('.tab-container');
    if (!activeTab || !bar || !container) return;
    const rect = activeTab.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    bar.style.left = (rect.left - containerRect.left) + "px";
    bar.style.width = rect.width + "px";
  }

  // Emoji/Text-Umschalter
  function setEmojiMode(on) {
  // Immer UI aktualisieren
  emojiMode = !!on;
  localStorage.setItem("emojiMode", emojiMode ? "1" : "0");
  tabs.forEach(tab => {
    tab.textContent = emojiMode ? tab.dataset.emoji : tab.dataset.full;
    tab.style.justifyContent = emojiMode ? "center" : "";
    tab.title = emojiMode ? tab.dataset.full : "";
  });
  requestAnimationFrame(updateHighlightBar);
}

  // Logik zum Umschalten anhand verf√ºgbarer Breite
  function evaluate() {
    if (window.skipAutoSwitch) return;
    const avail = container.clientWidth;
    if (!emojiMode && avail < THRESH_NARROW) {
      setEmojiMode(true);
    } else if (emojiMode && avail > THRESH_WIDE) {
      setEmojiMode(false);
    }
  }

  // Events
  let t;
  const debounced = () => { clearTimeout(t); t = setTimeout(evaluate, 120); };

  window.addEventListener("resize", debounced);
  if (window.ResizeObserver && container) {
    new ResizeObserver(debounced).observe(container);
  }

  // Initial auf gespeicherten Zustand setzen
  setEmojiMode(emojiMode);
  evaluate(); // pr√ºfen, ob aktueller Platz reicht

  // Highlight-Bar initial setzen
  setTimeout(updateHighlightBar, 150);
});
</script>

<script>
(function(){
  var original = window.setResolveLang;
  window.setResolveLang = function(lang, updateUrl){
    lang = (lang === "EN") ? "EN" : "DE";
    try { localStorage.setItem("lastResolveLang", lang); } catch(e) {}
    var single = document.getElementById('iframe-resolve');
    if (single) {
      // No toggling needed in unified player mode.
      return;
    }
    // Fallback: call original if it exists (dual-iframe mode)
    if (typeof original === "function") return original(lang, updateUrl);
  };
})();
</script>
<script>
(function() {
  function getHashTabAndQuery() {
    const hash = window.location.hash.replace(/^#/, '');
    const i = hash.indexOf('?');
    if (i === -1) return { tab: hash || 'atem', params: {} };
    const tab = hash.slice(0, i) || 'atem';
    const query = hash.slice(i + 1);
    const params = {};
    if (query) {
      query.split('&').forEach(pair => {
        if (!pair) return;
        const j = pair.indexOf('=');
        if (j === -1) return;
        const k = decodeURIComponent(pair.slice(0, j));
        const v = decodeURIComponent(pair.slice(j + 1));
        if (k) params[k] = v;
      });
    }
    return { tab, params };
  }
  const ALLOWED = new Set(['v','list','t','time','start']);
  function buildSrc(base) {
    base = base || 'EDL_video_player_for_resolve_2_0_EN_DE.html';
    const merged = {};
    const sp = new URLSearchParams(window.location.search);
    for (const [k,v] of sp.entries()) merged[k] = v;
    const { params } = getHashTabAndQuery();
    for (const k in params) merged[k] = params[k];
    const q = new URLSearchParams();
    Object.keys(merged).forEach(k => { if (ALLOWED.has(k)) q.set(k, merged[k]); });
    const qs = q.toString();
    return qs ? base + '?' + qs : base;
  }
  function updateResolveSrc() {
    const iframe = document.getElementById('iframe-resolve');
    if (!iframe) return;
    iframe.setAttribute('src', buildSrc());
  }
  function maybeInit() {
    const h = location.hash.replace(/^#/, '');
    const tab = h.split('?')[0] || 'atem';
    if (tab === 'resolve') updateResolveSrc();
  }
  window.addEventListener('hashchange', function() {
    setTimeout(updateResolveSrc, 0);
  });
  document.addEventListener('DOMContentLoaded', function() {
    maybeInit();
    document.querySelectorAll('.tab').forEach(function(el){
      el.addEventListener('click', function(){
        const target = el.getAttribute('data-target') || '';
        if (target === 'resolve') setTimeout(updateResolveSrc, 0);
      });
    });
  });
})();
</script>
<script>
(function(){
  // --- Config ---
  const ALLOWED = new Set(['v','list','t','time','start']);
  const POLL_MS = 450;           // polling cadence
  const PRIME_DELAY_MS = 650;    // extra delay after iframe load for mobile
  let pollTimer = null;
  let lastSeen = "";             // last seen child search string

  // --- Helpers ---
  function parseHash() {
    const h = location.hash.replace(/^#/, '');
    const i = h.indexOf('?');
    const tab = (i === -1 ? h : h.slice(0, i)) || 'atem';
    const params = {};
    if (i !== -1) {
      const sp = new URLSearchParams(h.slice(i+1));
      for (const [k,v] of sp.entries()) params[k]=v;
    }
    return { tab, params };
  }
  function mergedParams() {
    const merged = {};
    const sp = new URLSearchParams(location.search);
    for (const [k,v] of sp.entries()) merged[k]=v;
    const { params } = parseHash();
    for (const k in params) merged[k]=params[k];
    return merged;
  }
  function buildResolveSrc(base, extra) {
    base = base || 'EDL_video_player_for_resolve_2_0_EN_DE.html';
    const all = Object.assign({}, mergedParams(), extra||{});
    const qp = new URLSearchParams();
    Object.keys(all).forEach(k => { if (ALLOWED.has(k)) qp.set(k, all[k]); });
    const qs = qp.toString();
    return qs ? base + '?' + qs : base;
  }
  function setParentHashResolve(fromObj) {
    // Update only allowed keys
    const current = parseHash();
    const merged = Object.assign({}, current.params);
    Object.keys(fromObj||{}).forEach(k => { if (ALLOWED.has(k)) merged[k]=fromObj[k]; });
    const qp = new URLSearchParams();
    Object.keys(merged).forEach(k => qp.set(k, merged[k]));
    const newHash = '#resolve' + (qp.toString() ? ('?' + qp.toString()) : '');
    if (location.hash === newHash) return;
    try { history.replaceState(null, '', location.pathname + location.search + newHash); }
    catch(e) { try { location.hash = newHash; } catch(_) {} }
  }
  function applyResolveIframeSrc(extraParams) {
    const iframe = document.getElementById('iframe-resolve');
    if (!iframe) return;
    const next = buildResolveSrc(iframe.getAttribute('data-base') || undefined, extraParams);
    if (iframe.getAttribute('src') !== next) iframe.setAttribute('src', next);
  }
  function isResolveActive() {
    return (parseHash().tab === 'resolve');
  }

  // --- Poller (tolerant for mobile) ---
  function startPoller() {
    stopPoller();
    const iframe = document.getElementById('iframe-resolve');
    if (!iframe) return;
    pollTimer = setInterval(() => {
      try {
        const cw = iframe.contentWindow;
        if (!cw || !cw.location) return;
        const search = cw.location.search || "";
        if (search && search !== lastSeen) {
          lastSeen = search;
          const childParams = Object.fromEntries(new URLSearchParams(search).entries());
          const allowed = {};
          Object.keys(childParams).forEach(k => { if (ALLOWED.has(k)) allowed[k]=childParams[k]; });
          if (Object.keys(allowed).length) {
            setParentHashResolve(allowed);
          
            try { sessionStorage.setItem('edl_resolve_params', JSON.stringify(allowed)); } catch(e) {}
}
        }
      } catch(e) { /* maybe not ready yet; keep polling */ }
    }, POLL_MS);
  }
  function stopPoller() {
    if (pollTimer) { clearInterval(pollTimer); pollTimer = null; }
  }

  // --- Prime step after iframe load (fixes "first time doesn't work on mobile") ---
  function primeAfterLoad() {
    const iframe = document.getElementById('iframe-resolve');
    if (!iframe) return;
    // immediate try
    try {
      const cw = iframe.contentWindow;
      if (cw && cw.location && cw.location.search) {
        lastSeen = cw.location.search;
        const childParams = Object.fromEntries(new URLSearchParams(lastSeen).entries());
        const allowed = {};
        Object.keys(childParams).forEach(k => { if (ALLOWED.has(k)) allowed[k]=childParams[k]; });
        if (Object.keys(allowed).length) setParentHashResolve(allowed);
      
            try { sessionStorage.setItem('edl_resolve_params', JSON.stringify(allowed)); } catch(e) {}
}
    } catch(e) {}
    // delayed second try (mobile browsers sometimes need a tick more)
    setTimeout(() => {
      try {
        const cw = iframe.contentWindow;
        if (cw && cw.location && cw.location.search) {
          const search = cw.location.search;
          if (search !== lastSeen) {
            lastSeen = search;
            const childParams = Object.fromEntries(new URLSearchParams(search).entries());
            const allowed = {};
            Object.keys(childParams).forEach(k => { if (ALLOWED.has(k)) allowed[k]=childParams[k]; });
            if (Object.keys(allowed).length) setParentHashResolve(allowed);
          
            try { sessionStorage.setItem('edl_resolve_params', JSON.stringify(allowed)); } catch(e) {}
}
        }
      } catch(e) {}
    }, PRIME_DELAY_MS);
  }

  // --- Event wiring ---
  document.addEventListener('DOMContentLoaded', function(){
    // Keep iframe src aligned with current URL (important for direct links)
    applyResolveIframeSrc();
    // Prime + poll whenever Resolve is active
    const iframe = document.getElementById('iframe-resolve');
    if (iframe) {
      iframe.addEventListener('load', function(){
        if (isResolveActive()) {
          primeAfterLoad();
          startPoller();
        }
      });
    }
    // React on tab clicks to (re)apply src and restart poller on Resolve
    document.querySelectorAll('.tab').forEach(function(el){
      el.addEventListener('click', function(){
        const target = el.getAttribute('data-target') || '';
        if (target === 'resolve') {
          applyResolveIframeSrc();
          // wait a beat to let the player initialize its own params
          setTimeout(() => { primeAfterLoad(); startPoller(); }, 150);
        } else {
          stopPoller();
        }
      });
    });
  });

  window.addEventListener('hashchange', function(){
    // Any external hash change -> make sure iframe src matches
    applyResolveIframeSrc();
    // If resolve becomes active, ensure polling starts
    if (isResolveActive()) {
      // give the iframe a moment in case it reloads on new hash
      setTimeout(() => { primeAfterLoad(); startPoller(); }, 120);
    } else {
      stopPoller();
    }
  });

  // Optional: accept postMessage (if player sends it); used as an extra hint
  window.addEventListener('message', function(ev){
    if (!ev || !ev.data || ev.data.type !== 'RESOLVE_URL') return;
    const p = ev.data.params || {};
    const allowed = {};
    Object.keys(p).forEach(k => { if (ALLOWED.has(k)) allowed[k]=p[k]; });
    if (Object.keys(allowed).length) {
      setParentHashResolve(allowed);
      
            try { sessionStorage.setItem('edl_resolve_params', JSON.stringify(allowed)); } catch(e) {}
applyResolveIframeSrc(allowed);
    }
  }, false);
})();

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/service-worker.js')
      .then(registration => {
        console.log('Service Worker registered with scope:', registration.scope);
      })
      .catch(error => {
        console.error('Service Worker registration failed:', error);
      });
  });
}
</script>
</body>
</html>
